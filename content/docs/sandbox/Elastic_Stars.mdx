---
title: Elastic Stars
sidebar_label: Elastic Stars
hide_table_of_contents: true
slug: Elastic_Stars.html
---

**Instructions:** Drag and drop the stars and observe the elastic drop on dragend. Refresh the page to randomize the stars again.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs>
  <TabItem value="Vanilla" default>
```js live vanilla
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

let tween = null;

function addStar(layer, stage) {
  const scale = Math.random();

  const star = new Konva.Star({
    x: Math.random() * stage.width(),
    y: Math.random() * stage.height(),
    numPoints: 5,
    innerRadius: 30,
    outerRadius: 50,
    fill: '#89b717',
    opacity: 0.8,
    draggable: true,
    scale: {
      x: scale,
      y: scale,
    },
    rotation: Math.random() * 180,
    shadowColor: 'black',
    shadowBlur: 10,
    shadowOffset: {
      x: 5,
      y: 5,
    },
    shadowOpacity: 0.6,
    startScale: scale,
  });

  layer.add(star);
}

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

const layer = new Konva.Layer();
const dragLayer = new Konva.Layer();

for (let n = 0; n < 10; n++) {
  addStar(layer, stage);
}

stage.add(layer);
stage.add(dragLayer);

// bind stage handlers
stage.on('mousedown', function (evt) {
  const shape = evt.target;
  shape.moveTo(dragLayer);
  // restart drag and drop in the new layer
  shape.startDrag();
});

stage.on('mouseup', function (evt) {
  const shape = evt.target;
  shape.moveTo(layer);
});

stage.on('dragstart', function (evt) {
  const shape = evt.target;
  if (tween) {
    tween.pause();
  }
  shape.setAttrs({
    shadowOffset: {
      x: 15,
      y: 15,
    },
    scale: {
      x: shape.getAttr('startScale') * 1.2,
      y: shape.getAttr('startScale') * 1.2,
    },
  });
});

stage.on('dragend', function (evt) {
  const shape = evt.target;

  tween = new Konva.Tween({
    node: shape,
    duration: 0.5,
    easing: Konva.Easings.ElasticEaseOut,
    scaleX: shape.getAttr('startScale'),
    scaleY: shape.getAttr('startScale'),
    shadowOffsetX: 5,
    shadowOffsetY: 5,
  });

  tween.play();
});
```
  </TabItem>
  <TabItem value="React">
```js live react
import { useState, useRef, useEffect } from 'react';
import { Stage, Layer, Star } from 'react-konva';

const App = () => {
  const [stars, setStars] = useState([]);
  const [activeStar, setActiveStar] = useState(null);
  const [dragLayer, setDragLayer] = useState([]);
  const [mainLayer, setMainLayer] = useState([]);
  
  // Generate initial stars
  useEffect(() => {
    const initialStars = [];
    for (let n = 0; n < 10; n++) {
      const scale = Math.random();
      initialStars.push({
        id: n.toString(),
        x: Math.random() * window.innerWidth,
        y: Math.random() * window.innerHeight,
        numPoints: 5,
        innerRadius: 30,
        outerRadius: 50,
        fill: '#89b717',
        opacity: 0.8,
        rotation: Math.random() * 180,
        shadowColor: 'black',
        shadowBlur: 10,
        shadowOffset: {
          x: 5,
          y: 5,
        },
        shadowOpacity: 0.6,
        scale: {
          x: scale,
          y: scale,
        },
        startScale: scale,
        isDragging: false
      });
    }
    setStars(initialStars);
    setMainLayer(initialStars.map(star => star.id));
  }, []);
  
  const handleDragStart = (e) => {
    const id = e.target.id();
    const starIndex = stars.findIndex(star => star.id === id);
    
    if (starIndex === -1) return;
    
    // Update the star's properties
    const updatedStars = [...stars];
    updatedStars[starIndex] = {
      ...updatedStars[starIndex],
      isDragging: true,
      shadowOffset: {
        x: 15,
        y: 15,
      },
      scale: {
        x: updatedStars[starIndex].startScale * 1.2,
        y: updatedStars[starIndex].startScale * 1.2,
      }
    };
    
    // Move to drag layer
    setMainLayer(mainLayer.filter(starId => starId !== id));
    setDragLayer([...dragLayer, id]);
    setStars(updatedStars);
    setActiveStar(id);
  };
  
  const handleDragEnd = (e) => {
    const id = e.target.id();
    const starIndex = stars.findIndex(star => star.id === id);
    
    if (starIndex === -1) return;
    
    // Update the star's properties to animate back
    const updatedStars = [...stars];
    updatedStars[starIndex] = {
      ...updatedStars[starIndex],
      isDragging: false,
      shadowOffset: {
        x: 5,
        y: 5,
      },
      scale: {
        x: updatedStars[starIndex].startScale,
        y: updatedStars[starIndex].startScale,
      }
    };
    
    // Move back to main layer
    setDragLayer(dragLayer.filter(starId => starId !== id));
    setMainLayer([...mainLayer, id]);
    setStars(updatedStars);
    setActiveStar(null);
  };
  
  const handleDragMove = (e) => {
    const id = e.target.id();
    const starIndex = stars.findIndex(star => star.id === id);
    
    if (starIndex === -1) return;
    
    // Update the star's position
    const updatedStars = [...stars];
    updatedStars[starIndex] = {
      ...updatedStars[starIndex],
      x: e.target.x(),
      y: e.target.y()
    };
    
    setStars(updatedStars);
  };
  
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        {stars.filter(star => mainLayer.includes(star.id)).map(star => (
          <Star
            key={star.id}
            id={star.id}
            x={star.x}
            y={star.y}
            numPoints={star.numPoints}
            innerRadius={star.innerRadius}
            outerRadius={star.outerRadius}
            fill={star.fill}
            opacity={star.opacity}
            rotation={star.rotation}
            shadowColor={star.shadowColor}
            shadowBlur={star.shadowBlur}
            shadowOffset={star.shadowOffset}
            shadowOpacity={star.shadowOpacity}
            scale={star.scale}
            draggable
            onDragStart={handleDragStart}
            onDragEnd={handleDragEnd}
            onDragMove={handleDragMove}
          />
        ))}
      </Layer>
      <Layer>
        {stars.filter(star => dragLayer.includes(star.id)).map(star => (
          <Star
            key={star.id}
            id={star.id}
            x={star.x}
            y={star.y}
            numPoints={star.numPoints}
            innerRadius={star.innerRadius}
            outerRadius={star.outerRadius}
            fill={star.fill}
            opacity={star.opacity}
            rotation={star.rotation}
            shadowColor={star.shadowColor}
            shadowBlur={star.shadowBlur}
            shadowOffset={star.shadowOffset}
            shadowOpacity={star.shadowOpacity}
            scale={star.scale}
            draggable
            onDragStart={handleDragStart}
            onDragEnd={handleDragEnd}
            onDragMove={handleDragMove}
          />
        ))}
      </Layer>
    </Stage>
  );
};

export default App;
```
  </TabItem>
  <TabItem value="Vue">
```js live vue
<template>
  <v-stage :config="stageConfig">
    <v-layer>
      <v-star
        v-for="star in mainLayerStars"
        :key="star.id"
        :config="star"
        @dragstart="handleDragStart"
        @dragend="handleDragEnd"
        @dragmove="handleDragMove"
      />
    </v-layer>
    <v-layer>
      <v-star
        v-for="star in dragLayerStars"
        :key="star.id"
        :config="star"
        @dragstart="handleDragStart"
        @dragend="handleDragEnd"
        @dragmove="handleDragMove"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue';

const stageConfig = {
  width: window.innerWidth,
  height: window.innerHeight
};

const stars = ref([]);
const mainLayer = ref([]);
const dragLayer = ref([]);

// Computed properties to get stars for each layer
const mainLayerStars = computed(() => {
  return stars.value.filter(star => mainLayer.value.includes(star.id));
});

const dragLayerStars = computed(() => {
  return stars.value.filter(star => dragLayer.value.includes(star.id));
});

// Generate initial stars
onMounted(() => {
  const initialStars = [];
  const initialMainLayer = [];
  
  for (let n = 0; n < 10; n++) {
    const scale = Math.random();
    const id = n.toString();
    
    initialStars.push({
      id: id,
      x: Math.random() * window.innerWidth,
      y: Math.random() * window.innerHeight,
      numPoints: 5,
      innerRadius: 30,
      outerRadius: 50,
      fill: '#89b717',
      opacity: 0.8,
      rotation: Math.random() * 180,
      shadowColor: 'black',
      shadowBlur: 10,
      shadowOffset: {
        x: 5,
        y: 5,
      },
      shadowOpacity: 0.6,
      scale: {
        x: scale,
        y: scale,
      },
      startScale: scale,
      draggable: true
    });
    
    initialMainLayer.push(id);
  }
  
  stars.value = initialStars;
  mainLayer.value = initialMainLayer;
});

const handleDragStart = (e) => {
  const id = e.target.id();
  const starIndex = stars.value.findIndex(star => star.id === id);
  
  if (starIndex === -1) return;
  
  // Update the star's properties
  const star = {...stars.value[starIndex]};
  star.shadowOffset = {
    x: 15,
    y: 15
  };
  star.scale = {
    x: star.startScale * 1.2,
    y: star.startScale * 1.2
  };
  
  // Move to drag layer
  mainLayer.value = mainLayer.value.filter(starId => starId !== id);
  dragLayer.value = [...dragLayer.value, id];
  
  // Update star in the array
  stars.value[starIndex] = star;
};

const handleDragEnd = (e) => {
  const id = e.target.id();
  const starIndex = stars.value.findIndex(star => star.id === id);
  
  if (starIndex === -1) return;
  
  // Update the star's properties for animation back
  const star = {...stars.value[starIndex]};
  star.shadowOffset = {
    x: 5,
    y: 5
  };
  star.scale = {
    x: star.startScale,
    y: star.startScale
  };
  
  // Move back to main layer
  dragLayer.value = dragLayer.value.filter(starId => starId !== id);
  mainLayer.value = [...mainLayer.value, id];
  
  // Update star in the array
  stars.value[starIndex] = star;
};

const handleDragMove = (e) => {
  const id = e.target.id();
  const starIndex = stars.value.findIndex(star => star.id === id);
  
  if (starIndex === -1) return;
  
  // Update the star's position
  const star = {...stars.value[starIndex]};
  star.x = e.target.x();
  star.y = e.target.y();
  
  // Update star in the array
  stars.value[starIndex] = star;
};
</script>
```
  </TabItem>
</Tabs> 