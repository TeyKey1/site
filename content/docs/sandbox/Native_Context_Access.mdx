---
title: How to access native 2d context
sidebar_label: Native Context Access
hide_table_of_contents: true
slug: Native_Context_Access.html
---

## How to access native 2d canvas context from Konva

Konva gives you object model for drawing shapes on canvas. Your app is starting from a stage (div wrapper) and then the stage have one or many layers (canvas DOM elements) inside.

You can hijack into Konva internals (or DOM internals) and draw into canvas directly without creating any shapes. But that is not recommended. Because Konva has full control over drawing and may reset your manual drawings or lost them on any export such as `stage.toDataURL()`.

There are two recommended ways if you want to draw something manually:

1. [Use custom shape](/docs/shapes/Custom.html)
2. Create a new canvas element manually and then use it for `Konva.Image`.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs>
  <TabItem value="Vanilla" default>
```js live vanilla
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

const layer = new Konva.Layer();
stage.add(layer);

// if you want to make something with native 2d canvas
// we can create it and use it for Konva.Image
const canvas = document.createElement('canvas');
canvas.width = 200;
canvas.height = 150;
const ctx = canvas.getContext('2d');

const image = new Konva.Image({
  x: 50,
  y: 50,
  image: canvas,
  draggable: true,
});
layer.add(image);

// make manual drawings
ctx.fillStyle = 'blue';
ctx.fillRect(5, 5, canvas.width - 10, canvas.height / 2);
ctx.fillStyle = 'red';
ctx.beginPath();
ctx.arc(100, 75, 50, 0, 2 * Math.PI);
ctx.fill();

// such as canvas is updated we need to redraw the layer
layer.batchDraw();
```
  </TabItem>
  <TabItem value="React">
```js live react
import { Stage, Layer, Image } from 'react-konva';
import { useMemo, useState } from 'react';

const App = () => {
  const [position, setPosition] = useState({ x: 50, y: 50 });

  const canvas = useMemo(() => {
    const canvas = document.createElement('canvas');
    canvas.width = 200;
    canvas.height = 150;
    const ctx = canvas.getContext('2d');

    // make manual drawings
    ctx.fillStyle = 'blue';
    ctx.fillRect(5, 5, canvas.width - 10, canvas.height / 2);
    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.arc(100, 75, 50, 0, 2 * Math.PI);
    ctx.fill();

    return canvas;
  }, []);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Image
          x={position.x}
          y={position.y}
          image={canvas}
          draggable
          onDragEnd={(e) => {
            setPosition({
              x: e.target.x(),
              y: e.target.y(),
            });
          }}
        />
      </Layer>
    </Stage>
  );
};

export default App;
```
  </TabItem>
  <TabItem value="Vue">
```js live vue
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-image
        :config="{
          x: position.x,
          y: position.y,
          image: canvas,
          draggable: true,
        }"
        @dragend="handleDragEnd"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted } from 'vue';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const position = ref({ x: 50, y: 50 });
const canvas = ref(null);

onMounted(() => {
  const canvasEl = document.createElement('canvas');
  canvasEl.width = 200;
  canvasEl.height = 150;
  const ctx = canvasEl.getContext('2d');

  // make manual drawings
  ctx.fillStyle = 'blue';
  ctx.fillRect(5, 5, canvasEl.width - 10, canvasEl.height / 2);
  ctx.fillStyle = 'red';
  ctx.beginPath();
  ctx.arc(100, 75, 50, 0, 2 * Math.PI);
  ctx.fill();

  canvas.value = canvasEl;
});

const handleDragEnd = (e) => {
  position.value = {
    x: e.target.x(),
    y: e.target.y(),
  };
};
</script>
```
  </TabItem>
</Tabs>

